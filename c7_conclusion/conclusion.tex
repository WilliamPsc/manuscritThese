\chapter{Conclusion}
\chaptermark{Conclusion}
\label{chapter:conclusion}

\epigraph{\textit{The only truly secure system is one that is powered off, cast in a block of concrete and sealed in a lead-lined room with armed guards - and even then I have my doubts.}}{Gene Spafford}

\minitoc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synthesis}

With the rapid expansion of IoT and the growing ubiquity of embedded systems, ensuring robust security has become a critical priority for both hardware designers and software developers. Protecting these systems from potential threats, especially physical attacks, remains a key challenge. Among these threats, Fault Injection Attacks (FIAs) stand out as a significant risk due to their capacity to disrupt device operation and compromise data integrity.

FIAs are particularly dangerous because they allow attackers to inject faults into a system during runtime, potentially bypassing even the most robust software security mechanisms. By manipulating voltage, clock signals, or using techniques like laser-based injections, adversaries can induce unexpected behaviour, leading to data leakage, corruption, or system hijacking. These attacks are becoming more accessible due to the decreasing cost of fault injection tools, making it imperative to design systems with built-in resilience. Existing security mechanisms, like Dynamic Information Flow Tracking (DIFT), which is used as a security against software threats, are not immune to these attacks, necessitating deeper investigation and the development of tailored countermeasures. Without effective defences, FIAs remain a potent threat, capable of undermining the reliability and trustworthiness of critical IoT systems.

This thesis aims to address these challenges by assessing vulnerabilities and proposing lightweight countermeasures to strengthen digital systems against FIAs. By evaluating and improving the security of Dynamic Information Flow Tracking (DIFT) mechanisms, we propose a solution on how to protect systems against sophisticated physical and software-based threats. In this concluding chapter, we summarise the contributions made, reflect on the findings, and discuss the potential for further advancements in securing embedded systems against physical attacks.

In the second chapter, we systematically introduced the three main parts of this research. First, we provided a comprehensive explanation of hardware-based DIFT and conducted a detailed review of the state-of-the-art of Information Flow Tracking methodologies, spanning software implementations, hardware solutions, and co-design approaches that integrate both. Second, we categorised various forms of physical attacks, with a particular emphasis on an in-depth analysis of FIAs and their diverse mechanisms for compromising system security. Finally, we presented a critical overview of the existing countermeasures designed to effectively protect systems against FIAs, laying the foundations for the subsequent development of enhanced lightweight protection strategies.

In the third chapter, we presented the processor utilised in this work, detailing its implementation of in-core hardware-based DIFT and demonstrating its use in its default configuration. In the second part, we described three specific use cases developed to analyse the behaviour of the DIFT mechanism, and we conducted a theoretical assessment of its resilience against FIAs, considering classical single fault models such as \textit{bit set}, \textit{bit reset}, and \textit{single bit-flip}. Finally, we evaluated the DIFT's vulnerabilities through simulation campaigns to validate our theoretical results. Our findings revealed that the DIFT mechanism is predominantly vulnerable to single bit-flip faults due to its 1-bit data path. The fault injection simulations corroborated these results, highlighting critical registers that varied depending on the specific use case under consideration.

In the fourth chapter, we introduced FISSA (Fault Injection Simulation for Security Assessment), a novel open-source tool developed to support \textit{Security by Design}. FISSA enables designers to assess the security of their systems during the conceptual phase of development. Seamlessly integrated with well-known HDL tools and simulators, such as Questasim, FISSA accepts a set of parameters and generates corresponding TCL scripts, which are executed within the HDL simulator. Each simulation produces detailed JSON log files, providing a comprehensive basis for security analysis. The tool is highly configurable, allowing designers to tailor it to meet specific design requirements, offering flexibility in the evaluation process.

In the fifth chapter, we proposed and implemented three lightweight countermeasures to enhance the security of the D-RI5CY mechanism. The first countermeasure involves the use of simple parity as a fault detector. Upon detecting a fault, the parity bit triggers a signal to alert the system. The second countermeasure employs Hamming Code as a single fault corrector, capable of detecting and correcting single-bit errors with a 100\% accuracy at cycle accurate. This technique effectively corrected all single bit-flips induced by the fault models evaluated in Chapter~\ref{chapter:dift_assessment}. However, with the advent of more sophisticated fault injection platforms capable of inducing multiple faults, single bit-flips are no longer the predominant threat. This led to the introduction of more complex fault models, such as \textit{single bit-flip in two registers at two distinct clock cycles}. To address this, we implemented the third countermeasure, SECDED (Single Error Correction, Double Error Detection), which extends the Hamming Code by adding another bit for parity to enable the detection of double-bit errors. These three countermeasures demonstrated strong effectiveness against the fault models considered, while maintaining minimal impact on system performance and area overhead.

In the sixth chapter, we took into account even more complex fault models, such as \textit{single bit-flip in two registers at one clock cycle}, \textit{multi-bit faults in one register at a given clock cycle}, and \textit{multi-bit faults in two registers at a given clock cycle}. These fault models access the limit of our three countermeasures. As we can inject two to twelve faults at the same time, the possibilities of detection and correction are not enough. To achieve a better protection by staying with our three lightweight countermeasures, we decided to evaluate different group composition on our encoders. This evaluation allowed to assess the security performances of each strategy and take into account the performance and area overhead induced by each strategy to better compare them for a small embedded system. Thanks to these strategies, we have shown better security performances by doing some compromises on the size. However, with an increase of 5\% of our processor size, we are able to detect and correct the vast majority of previous successful attacks. For the remaining successes, a better protection would need to be evaluated, such as a better ECC (BCH code, for example).

Finally, to conclude this part, all the experiments were carried out on a server with the following configuration Xeon Gold 5220 (2.2~GHz, 18C/36T), 128~GB RAM, Ubuntu 20.04.6 LTS and Questasim 10.6e. We ran \num{23935697} simulations for all our fault models, and each simulation took an average of 3.29 seconds to run on our server.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Perspectives}

In terms of perspectives, this work has reached its primary objective: to propose a protected DIFT mechanism against FIAs. However, many possibilities still exist to pursue this research. A non-exhaustive list of perspectives is thus provided hereunder.

In this work, we focused on a specific implementation of DIFT that utilises 1-bit tags. However, other implementations, such as the one discussed in~\cite{DKK-07-sigarch}, feature multi-bit tags, and there exist more complex CPUs with advanced features such as deeper pipelines, prefetching, speculation, and out-of-order execution. The vulnerabilities of DIFT mechanisms may vary depending on these architectural differences. A comprehensive evaluation of different DIFT implementations is needed to gain a broader understanding of their vulnerabilities and to propose effective countermeasures for these systems.

An additional avenue for extending this research lies in the further development of FISSA. This could include expanding support to a wider range of HDL tools, such as Vivado and Verilator. Moreover, FISSA should incorporate more fault models from the literature, including those targeting laser-based fault injection, X-ray attacks, and other emerging techniques. Improving its integration into the design workflow is essential for ensuring ease of use, allowing designers to adopt the tool more readily. Additionally, the implementation of a graphical user interface (GUI) would enhance usability by offering a direct and intuitive means of analysing simulation results.

A third perspective for future work is to conduct real-world FIAs on an FPGA board to assess the D-RI5CY processor’s vulnerabilities under actual conditions. This would enable verification of the effectiveness of our proposed countermeasures, extending beyond simulation results to ensure real-world reliability. In particular, this approach would allow a thorough evaluation of the two CSR registers against multi-bit faults, a task that was not fully feasible through simulation.

Despite our proposed countermeasures, as demonstrated in Chapter~\ref{chapter:exp_setup_results}, some FIAs may still succeed. To achieve comprehensive protection, enhanced multi-bit fault mitigation strategies are required. This could involve introducing redundancy into the registers or refining the Error Correction Code (ECC) by implementing more robust linear or cyclic codes, such as Low-Density Parity-Check (LDPC), Bose–Chaudhuri–Hocquenghem (BCH) codes, or Reed-Solomon codes. Although these codes offer the potential to correct multiple-bit errors, they also come with significant overhead in terms of area and computational complexity. For instance, BCH codes often require multiple cycles to execute, and while they can theoretically be designed to operate in a single cycle, the area costs would be substantial. Therefore, a careful evaluation is necessary to strike a balance between performance and security.

Finally, a long-term perspective worth exploring is whether a DIFT mechanism could detect FIAs occurring within the processor itself. A fault injection could alter the instruction path, modify a value, or even compromise a tag, allowing the DIFT to detect such errors. The behaviour of DIFT in response to FIAs should be thoroughly assessed to determine its viability as a built-in protection mechanism.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%